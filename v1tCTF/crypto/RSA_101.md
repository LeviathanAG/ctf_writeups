# rsa_101 


```import math as m
import sympy as sp


p=101
q = 313846144900241708687128313929756784551

n = 31698460634924412577399959706905435239651
e = 65537
c = 23648999580642514140599125257944114844209

y=p*q
print(y)
print(y==n)

print(sp.isprime(p))
print(sp.isprime(q))
phi = (p-1)*(q-1)
print(phi)
d = pow(e, -1, phi)
print(d)

print(sp.isprime(n))
```

- Found p and q on factor db and these tests verify that p and q are correct.

- out : 
```
31698460634924412577399959706905435239651
True
True
True
31384614490024170868712831392975678455000
15149971222460666029915912140442476213473
False
```

- recovered data is not ascii so this is not the approach.



In standard RSA, the plaintext message `m` must satisfy `m < n` for the encryption to work correctly. in this challenge, the m was actually larger than `n`, which means when it was encrypted, it got reduced modulo `n`. 

When we decrypt the ciphertext using the standard RSA  `m = c^d mod n`, we get back the reduced message, Tto recover original message, we need to add `n` back to this decrypted value.

```python
import sympy as sp

p = 101
q = 313846144900241708687128313929756784551
n = 31698460634924412577399959706905435239651
e = 65537
c = 23648999580642514140599125257944114844209


phi = (p-1)*(q-1)
d = pow(e, -1, phi)


m_decrypted = pow(c, d, n)
print("Decrypted", m_decrypted)

#  message is m + n 
actual_m = m_decrypted + n


hex_str = hex(actual_m)[2:]
flag = bytes.fromhex(hex_str).decode()
print("Flag:", flag)
```

**Flag:** `v1t{RSA_101_b4by}`

