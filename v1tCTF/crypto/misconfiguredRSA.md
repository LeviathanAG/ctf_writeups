# misconfiged rsa

```
n = 148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551
e = 65537
c = 107217087223013352864419426588613439434708031699522027786711684217439431898186052583896596846379575153070982123347045493427454234913154021933229641985591412104222934496019950746514726800406326146713516918611779367873873294259462206805554572977819244626333164240237423211396727885901436510649294574529712562954
```

- i tried looking up n in factorDB and it said prime so i reverified using :
```py

import sympy as sp
p= 148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551
print(sp.isprime(p))
```

which confirmed it.

now we can easily decrypt using normal rsa reversal algorithm since our phi is (p-1) :


```
import math as m
import sympy as sp

n=148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551
e=65537
c=107217087223013352864419426588613439434708031699522027786711684217439431898186052583896596846379575153070982123347045493427454234913154021933229641985591412104222934496019950746514726800406326146713516918611779367873873294259462206805554572977819244626333164240237423211396727885901436510649294574529712562954

p =148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551




def egcd(a, b):
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)

def modinv(a, m):
    try:
        return pow(a, -1, m)
    except TypeError:
        g, x, _ = egcd(a, m)
        if g != 1:
            raise ValueError("Modular inverse does not exist")
        return x % m

def int_to_bytes(i):
    return i.to_bytes((i.bit_length() + 7) // 8, 'big')


phi = (p - 1)
d = modinv(e, phi)
m = pow(c, d, n)


plaintext = int_to_bytes(m).decode()
print(f"{plaintext}")

```

out :
```
v1t{f3rm4t_l1ttl3_duck}
```


flag : `v1t{f3rm4t_l1ttl3_duck}`

# misconfiged rsa

```
n = 148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551
e = 65537
c = 107217087223013352864419426588613439434708031699522027786711684217439431898186052583896596846379575153070982123347045493427454234913154021933229641985591412104222934496019950746514726800406326146713516918611779367873873294259462206805554572977819244626333164240237423211396727885901436510649294574529712562954
```

- i tried looking up n in factorDB and it said prime so i reverified using :
```py

import sympy as sp
p= 148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551
print(sp.isprime(p))
```

which confirmed it.

now we can easily decrypt using normal rsa reversal algorithm since our phi is (p-1) :


```
import math as m
import sympy as sp

n=148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551
e=65537
c=107217087223013352864419426588613439434708031699522027786711684217439431898186052583896596846379575153070982123347045493427454234913154021933229641985591412104222934496019950746514726800406326146713516918611779367873873294259462206805554572977819244626333164240237423211396727885901436510649294574529712562954

p =148900953097814724338206947679223698832179691968218755697733749707084556942286184505525791780949441847197006147827388400754499224336852575956050210608024912280019773833889546324355353746095214275985515374968532505153145975517881297436944244066461866248895871696012367810254055557824874852294865749524482337551




def egcd(a, b):
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)

def modinv(a, m):
    try:
        return pow(a, -1, m)
    except TypeError:
        g, x, _ = egcd(a, m)
        if g != 1:
            raise ValueError("Modular inverse does not exist")
        return x % m

def int_to_bytes(i):
    return i.to_bytes((i.bit_length() + 7) // 8, 'big')


phi = (p - 1)
d = modinv(e, phi)
m = pow(c, d, n)


plaintext = int_to_bytes(m).decode()
print(f"{plaintext}")

```

out :
```
v1t{f3rm4t_l1ttl3_duck}
```


flag : `v1t{f3rm4t_l1ttl3_duck}`